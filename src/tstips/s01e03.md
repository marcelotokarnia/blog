---
title: S01E03 - Overloads, overwrites, extensions, how to mix and match types
summary: A list of awesome intermediate/advanced TS functionalities, often underused by professionals
date: 2020-08-21
author: Marcelo Tokarnia
authorPic: https://res.cloudinary.com/marcelotokarnia/image/upload/c_thumb,g_face:center,r_max,h_150,w_150,f_auto,q_auto/v1590609457/profile/A54I1782_qa84qz.jpg
tags: TS,Typings,Typescript
---

Typing is great! I guess we can all agree with that, but sometimes we would like to reuse a few types, by composing multiple small types into a big one, or telling how should a function behave in case it gets a different number of parameters, you name it, this section is focused on juggling multiple type definitions in order to achieve the desired outcome.

## extends

One interface can `extend` another. It's the inheritance equivalent for types.

In sum, the extending class will have all the properties of the extended class, and you can overwrite these properties, but only to a sub-type of the extended type, and, of course, you can add new properties.

```js
interface Animal {
  name: string
  isRodent: boolean
  eat: string
}

interface Squirrel extends Animal {
  isRodent: true // ğŸ‘ğŸ» that's ok, true is a sub type of boolean
  isAdult: boolean // ğŸ‘ğŸ» it's ok, new properties are allowed
  eat: number // ğŸ’£ğŸ’¥ number is not a subtype of string
// ğŸ‘†ğŸ» Interface 'Squirrel' incorrectly extends interface 'Animal'.
// Types of property 'eat' are incompatible.
// Type 'number' is not assignable to type 'string'.ts(2430)
}

const sqrl: Squirrel = getSquirrel()

sqrl.isRodent // ğŸ‘ğŸ» this will always be compiled to true
sqrl.isAdult // ğŸ‘ğŸ» created new prop
sqrl.name // ğŸ‘ğŸ» even if not mentioned in Squirrel definition
// it exists because of the Animal definition
```

The same interface can `extend` multiple other interfaces, as long as they don't have clashing properties:

```js
interface FourLegged {
  legs: 4;
}

interface Rodent {
  isRodent: true;
}

interface Squirrel extends FourLegged, Rodent {
  isAdult: boolean; // ğŸ‘ğŸ» FourLegged and Rodent have no clashing properties
  // Squirrel will end up with 3 properties:
  // legs: 4; isRodent: true; isAdult: boolean
}
```

But if you try to do:

```js
interface Animal {
  isRodent: boolean
  legs: number
}

interface Rodent {
  isRodent: true
}

interface Squirrel extends Animal, Rodent {
  isAdult: boolean // ğŸ’£ğŸ’¥ The compiler will not know the interfaces precedence,
  // so you can't overwrite types, even with subtypes
  // ğŸ‘†ğŸ» Interface 'Squirrel' cannot simultaneously extend types 'Animal' and 'Rodent'.
  // Named property 'isRodent' of types 'Animal' and 'Rodent' are not identical.ts(2320)
}
```

But in this case, we know all Rodents are Animals, so we can tell the compiler to precedence order by doing:

```js
interface Animal {
  isRodent: boolean
  legs: number
}

interface Rodent extends Animal {
  isRodent: true
}

interface Squirrel extends Rodent {
  isAdult: boolean // ğŸ‘ğŸ»ğŸ’ªğŸ» Great Success
}
```

If you do need to overwrite a prop with a totally different type, chances are, you've been making some poor decisions on your data modelling and might be a good idea to rethink the structure, BUT if you really need to, you can extend a generated type by the [Omitting](/ts/s01e01#pick-and-omit) a few props.

Reference:

- [Extensions - Typescript Handbook][extensions-handbook]

## overloads

"JavaScript is inherently a very dynamic language. Itâ€™s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in." -- Handbook

You have probably already clicked a package function while working on a IDE to go to it's definition, and most likely it looks like this:

```js
// @types/ramda/index.d.ts
export function map<T, U>(fn: (x: T) => U, list: readonly T[]): U[];
export function map<T, U>(fn: (x: T) => U): (list: readonly T[]) => U[];
export function map<T, U>(fn: (x: T[keyof T & keyof U]) => U[keyof T & keyof U], list: T): U;
export function map<T, U>(fn: (x: T[keyof T & keyof U]) => U[keyof T & keyof U]): (list: T) => U;
export function map<T, U>(fn: (x: T) => U, obj: Functor<T>): Functor<U>; // used in functors
export function map<T, U>(fn: (x: T) => U): (obj: Functor<T>) => Functor<U>; // used in functors
```

The same function is "defined" more than once with a different number/shape of parameters. And that's okay for typescript, even though javascript will not accept more than one function **logic definition**, you can write more than one function **type declaration**.

And the compiler will go through all of them, **from top to bottom**, trying to match your usage of that function in order to infer the ReturnType.

In other words, the **order does matter** and you should go from specific to generic in order to avoid an "early generic match".

```js
interface GenericFirst {
  (p: any): any
  (p: string): string
}

interface SpecificFirst {
  (p: string): string
  (p: any): any
}

const genFirst: GenericFirst = p => p

const specFirst: SpecificFirst = p => p

const n = genFirst('string') // n evaluates to any
const s = specFirst('string') // s evaluates to string
```

There are multiple ways to declare overloads, this was the interface approach, but on the handbook you will find the function approach, and the are others.

As seen above, [Ramda](https://ramdajs.com/) uses A LOT of overloads because basically all their functions are curried, so if a function is expecting 3 params and only receives 1 it will return a function that is expecting 2, and all the possible sub group combinations of N params for all their functions ğŸ˜‚ it's a lot of overloads, and works amazingly well. ğŸ‘ğŸ» Good job Ramda people. ğŸ‰

Even though it's not totally recommended by the REST spec, it's very common to see APIs that either accepts an extra parameter that will convert the response from a mapped object to an array, or to have an input, like an id lookup, that if receives a string (single ID), the API will respond that id match, but if receives an array with IDs, the API will respond an array with all id matches.

And that's another case where overloads can shine.

```js
type ConvertableMethod<P extends ConvertableParams> = {
  (p: Omit<P, 'key_by_type'> & { key_by_type: true }): MethodResponse<StreamSetObj>
  (p: P): MethodResponse<StreamSetArr>
}
```

[Strava Streams API][strava-streams-api]

If `key_by_type` param is true, the API respond with a mapped object, otherwise with an Array.

References:

- [Overloads - Typescript Handbook][overloads-handbook]

## union and intersection

Unions and Intersections

---

<div>
<a href="/ts/s01e04" style="float: right; padding-bottom: 15px">Survival Tricks ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»</a>
<a href="/ts/s01e02" style="float: left; padding-bottom: 15px">ğŸ‘ˆğŸ»ğŸ‘ˆğŸ»ğŸ‘ˆğŸ» Conditional Typing</a>
</div>
<br/>

<!-- extends References  -->

[extensions-handbook]: https://www.typescriptlang.org/docs/handbook/interfaces.html#extending-interfaces

<!-- overloads References  -->

[overloads-handbook]: https://www.typescriptlang.org/docs/handbook/functions.html#overloads
[strava-streams-api]: https://github.com/marcelotokarnia/strava-maps/blob/0b50362605e861bb1d47ca5bfb98c0f280c171cd/packages/strava/src/typings/api/streams.ts#L11

<!-- union and intersection References  -->
